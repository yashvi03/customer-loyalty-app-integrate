worker_processes 1;
error_log /dev/stdout info;
pid /tmp/nginx.pid;

events {
  worker_connections 1024;
}

http {
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;
  access_log /dev/stdout;
  sendfile on;

  # Upstream server for the first Flask app (HTML templates)
  # We'll run it on internal port 8001
  upstream Flask_app1 {
    server 127.0.0.1:8001;
  }

  # Upstream server for the second Flask app (API for React)
  # We'll run it on internal port 8002
  upstream Flask_app2 {
    server 127.0.0.1:8002;
  }

  server {
    # Listen on the dynamic port Heroku assigns
    listen <%= ENV["PORT"] %>;

    # === ROUTE for the React App's static files ===
    # Requests to /app2/ serve the built React app
    location /app2/ {
      alias /app/React_app/build/;
      try_files $uri $uri/ /app2/index.html;
    }

    # === ROUTE for the React App's API ===
    # Requests to /api2/ are sent to the second Flask app
    location /api2/ {
      proxy_pass http://Flask_app2;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }

    # === ROUTE for the first Flask app (CATCH-ALL) ===
    # All other requests are sent to the first Flask app
    location / {
      proxy_pass http://Flask_app1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }
  }
}